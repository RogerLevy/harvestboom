+sin  \ enable tokenization of all definitions from here

require config/options.vfx
require config/allegro.vfx

cwd vfxland3
require lib/vl3/vfxland3.vfx
require lib/csv.vfx
require plugins/engine1.vfx
require plugins/bitmaps2.vfx
require plugins/tilemap4.vfx
require lib/files1.vfx
cwd %idir%

include lib/str.vfx

-sin  \ disable tokenization of all definitions from here

\ ------------------------------------------------------------------------------

: read-csv,  read> lines> csv> evaluate , ;

s" tiled/1-1_active1.csv"  create active.arr  read-csv,

z" assets/castle-tileset.png" loadbmp constant castle.bmp
castle.bmp 16 16 create-tileset castle.ts  

z" assets/Simple Farm Packv12-export-export.png" loadbmp constant farm.bmp
farm.bmp 16 16 create-tileset farm.ts

s" tiled/1-1_ground1.csv"  create ground1.arr read-csv,
s" tiled/1-1_ground2.csv"  create ground2.arr read-csv,

\ ------------------------------------------------------------------------------

variable level

\ ------------------------------------------------------------------------------

include actors/player.vfx

\ ------------------------------------------------------------------------------

0 0 at  root to joan
create g1  ground1.arr farm.ts 20 15 *tilemap drop 
create g2  ground2.arr farm.ts 20 15 *tilemap drop
create a1  active.arr farm.ts 20 15 *tilemap drop
create gp  %scene ** drop
create p1  %player ** as  a1 map !  50 50 x v!  0 0 vx v!

\ ------------------------------------------------------------------------------

create tile-objects  1024 cells allot&erase

: clear-tile  -1 swap ! ;

variable object-tile  \ allows objects to know the tile # that spawned them

: load-tile-objects  ( tilemap - )
    gp clear  gp to joan  [[
    tm-base @  tm-rows 0 do
        tm-cols 0 do
            dup @ 0 >= if
                dup @ cells tile-objects + @ ?dup if
                    over @ object-tile !  over clear-tile  
                    i ts @ tilew *  j ts @ tileh *  at   
                    ( kind ) ** [[ cr .actor ]]
                then
            then
            cell+
        loop
    loop  drop ]] ;

\ ------------------------------------------------------------------------------

: csv-ints  ( $ c - a )
    cr 2dup type
    here -rot  read> lines> csv> evaluate , ;

\ ------------------------------------------------------------------------------

%actor kind: %level ;kind

\ ------------------------------------------------------------------------------

create levels  100 cell allot&erase

: prefix  pad count ;

: layer,  ( a:base a:ts - )
    20 15 *tilemap drop ;

\ ( $ c ) = "suffix.ext", pad = level name
: level-layer,  ( $ c - )  
    s" tiled/"  prefix $+  2swap $+  csv-ints farm.ts layer, ;

: declare-level  ( n - <name> )
    >in @ create
    %level static,  me rot cells levels + !  me to joan
        >in ! bl parse pad place
        s" _ground1.csv" level-layer,
        s" _ground2.csv" level-layer,
        s" _active1.csv" level-layer, ;

\ ------------------------------------------------------------------------------

include tile-objects.vfx
include levels.vfx

\ ------------------------------------------------------------------------------

: load-level  ( level - )
    -> first @ dup count-tilemap g1 -> tm-base @  swap move
    -> next @ dup count-tilemap g2 -> tm-base @  swap move
    -> next @ count-tilemap a1 -> tm-base @  swap move
    a1 load-tile-objects ;
        
: play  ( n - )
    dup cells levels + @ dup 0= if  2drop  exit  then
    swap  level !  load-level ;
